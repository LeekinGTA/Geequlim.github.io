---
layout: post
title: 你好三角形
category: 'BGFX'
tags: 'bgfx'
previousTitle: '创建BGFX渲染窗口'
previousUrl: '/2015/11/06/创建BGFX渲染窗口.html'
nextTitle: ''
nextUrl: ''
description:
---

## 图形渲染管线(Pipeline)

现代图形渲染库大都使用图形渲染管线将3D图形数据转换为2D像素阵列，这一过程也是大部分图形渲染工作的核心工作。所谓图形渲染管线，实际上指的是一堆原始图形数据经一步接一步地处理，最终将这些数据转化为可以显示到屏幕的过程，人们因其流水线式的工作方式将其称之为渲染管线。图形渲染管线可以被划分为两个主要部分：第一个部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。

图形渲染管线接收一组3D坐标，然后把它们转变为你屏幕上的有色2D像素，这一过程孩可以被细分为几个阶段，每个阶段需要把前一个阶段的输出数据作为输入数据。所有这些阶段都是高度专门化的(它们有一个特定的函数)，它们能简单地并行执行。由于它们的并行执行特性，当今大多数显卡都有成千上万的小处理核心，在GPU上为每一个(渲染管线)阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据，这些小程序叫做**着色器(Shader)** 。

有些着色器允许开发者自己配置，我们可以用自己写的着色器替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，因为它们运行在GPU上，所以它们会节约宝贵的CPU时间。BGFX的着色器是用类似OpenGL的着色器语言GLSL(OpenGL Shading Language, GLSL)写成的，因为现在作者还没有对这门着色器语言起一个名字，我们现在先把这门简单的着色器语言称之为BSL（BGFX Shading Language）吧，如果以后这个新生儿有户口了我们再改过来。我们在下一节会花更多时间研究这门着色器语言。

下图是OpenGL的图形渲染管线示意图，其他API的图形渲染管线与之类似，着色器的名称可能会有所不同。BGFX也是基于这些的图形渲染管线进行图形渲染工作的。

<img class="box_content" src="/assets/img/blog/LearnOpenGL/01 Getting started/OpenGL_pipline_cn.png"/>

如你所见，图形渲染管线包含很多部分，每个都是将你的顶点数据转变为最后渲染出来的像素这个大过程中的一个特定阶段。我们会概括性地解释渲染管线的每个部分，从而使你对图对渲染管线的工作方式有个大概了解。

<div class="orange_box">
	<p class="orange_title">BSL不能直接在硬件上执行</p>
	<p class="box_content">
虽然着色器设计的目的是让其在硬件上执行以提高渲染效率和渲染的可控范围。BSL是一门通用着色器语言，它并没有得到硬件厂商的支持。也就是说，BSL无法直接在GPU上作为着色器执行。BSL同BGFX一样，为了跨平台，提高开发效率而设计开发的，因此我们只要使用BSL写一遍着着色器程序，然后使用着色器编译器<b>shaderc</b>将其编译成各个平台的原始着色器，通过这种方式做到跨平台的。目前<b>shaderc</b>支持将BSL着色器程序编译成GLSL、HLSL、GLSLES和Metal的着色器程序，同时Karadžić称未来会在第一时间支持Vulkan。按理说在运行时将BSL编译为其他硬件可执行的着色器代码是可行的，但是现在大多数人并不会这样做，因为这样会牺牲掉大把的CPU运算时间。现在主流的做法是，在开发时进行着色器编译，这是提高渲染效率的一种途径。
	</p>
</div>

我会演示如何编写两个简单BSL着色器，并将他们编译成二进制文件，以及如何使用这两个着色器帮助我们绘制第一个三角形。下面是一个简单的BSL着色器代码。


新建一个名为`varying.def.sc`的着色器，该着色器用于声明在定点着色器和片段着色器中的输入/输出变量。本例只需要一个定点属性作为三角形的定点位置输入。

```glsl
vec3 a_position  : POSITION;
```


新建名为`vertex_shader.sc`的顶点着色器，使用`$input`指令引入我们声明的顶点属性作为输入数据。并将其复制给顶点输出数据`gl_Position`。
```glsl
$input a_position
void main()
{
    gl_Position = vec4(a_position, 1.0);
}
```
在BGFX着色器中位置使用4维向量来表示，该向量的前三个分量用于表示位置的x、y、z坐标，第四个分量一般非0即1，当最后一个分量是0时表示该向量是一个方向而不是具体的位置。

新建名为`fragment_shader.sc`的片段着色器，将输出颜色设置为橘红色。
```glsl
void main()
{
    gl_FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
```

BGFX片段着色器使用`gl_FragColor`作为最终输出颜色。颜色也使用一个四维向量表示，其每个分量的取值范围在[0,1]范围内，分别表示红、绿、蓝、不透明度。

这个着色器程序已经足够简单，本节的目的是探究BGFX绘图过程，更多着色器的知识会在下一节展开讨论。

接下来需要使用`shaderc`这个BGFX着色器编译器将这两个着色器编译成二进制形式。`shaderc`可在bgfx目录下使用`make tools`进行构建。Windows上需要使用Visual Studio生成。关于`shaderc`的用法可以通过`shaderc  --help`获取到。

可能你一下子不会用，或者觉得逐平台编译着色器比较麻烦，你可以下载我写的这个[编译脚本](https://github.com/Geequlim/ScriptTools/blob/master/bgfx/compileShader.py)，使用该脚本编译要简单方便一些。下载后需要对该脚本修改，将第2行的`shaderc`变量值设为你`shaderc`编译器的绝对路径才能正常工作。同样可以使用`python compileShader.py --help`获取帮助。

```bash
$ python compileShader.py --type vertex --file vertex_shader.sc --output shaders
$ python compileShader.py --type fragment --file fragment_shader.sc --output shaders
```
如果没什么问题的话你会得到多个版本的二进制着色器：
```
shaders
├── dx11
│   ├── fragment_shader.bin
│   └── vertex_shader.bin
├── dx9
│   ├── fragment_shader.bin
│   └── vertex_shader.bin
├── gles
│   ├── fragment_shader.bin
│   └── vertex_shader.bin
├── glsl
│   ├── fragment_shader.bin
│   └── vertex_shader.bin
└── metal
    ├── fragment_shader.bin
    └── vertex_shader.bin
```
注意，dx9和dx11版本的二进制着色器需要在Windows下进行编译。

至此，用于渲染我们的三角形的BGFX着色器已经完成了。接下来开始介绍如何使用它来绘制出我们期待已久的三角形小朋友。
