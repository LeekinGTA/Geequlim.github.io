---
layout: post
title: 创建BGFX渲染窗口
category: 'BGFX'
tags: 'bgfx'
previousTitle: ''
previousUrl: ''
nextTitle: ''
nextUrl: ''
description:
---

BGFX是一个跨平台的图形渲染库，其本身是不包括窗口创建这类平台相关的代码的，这也使得它看上去不是那么复杂。事实上要我们自己来为各个平台实现渲染窗口的创建工作肯定不是一件容易做到的事，者需要我们对各个操作系统的编程环境有一定了解。同时，我们不仅仅需要创建一个渲染窗口这么简单，我们还可能需要处理来自各个平台的事件、操作各个平台的文件等，这肯定是一件令人发疯的体力活。其实，如果是为了学习BGFX绘图库，我们完全没必要自己写一遍这些无聊的平台相关的东西，因为已经有勤劳的人儿做过这些事了，并且他们无私地把他们的劳动成果贡献出来了，我们直接用就行了。方便起见，我使用的是BGFX的示例里的代码，起码这些代码的实现是可靠的，因为哪些示例程序我们已经成功的编译运行过了是吧。

## 使用BGFX的entry

### `_main_`　入口函数

BGFX的示例程序通过entry相关的代码实现创建各个平台的渲染窗口，提供一个统一的程序入口`_main_`作为我们可以看作是BGFX绘图程序中的`main`入口函数。具体实现我们现在可以先不用进行深入了解，我们现在要学习的是BGFX这个绘图库而不是如何创建跨平台窗口对吧，当然如果你对其实现感兴趣也可以去看它的示例中[entry部分的源代码](https://github.com/bkaradzic/bgfx/tree/master/examples/common/entry)。

使用示例entry创建的渲染窗口程序，我们认为它是以`_main_`函数作为程序的入口，因此我们要定义该函数,所有的程序都在这个函数内执行（或写在其他地方在此函数内调用）。

#### 初始化BGFX

在使用BGFX之前，我们们必须使用`bgfx::init()`对它进行初始化。这里我们对其进行初始化以后需要设置窗口大小和BGFX的视口大小为，以及调试方式等，在程序结束时我们还需要调用`bgfx::shutdown()`函数来关闭BGFX。

```c++
int _main_(int _argc, char** _argv*)
{
    unsigned width = 1280;
    unsigned height = 720;
    unsigned debug = BGFX_DEBUG_TEXT;
    unsigned reset = BGFX_RESET_VSYNC;
    bool initialed = bgfx::init();
    if( initialed )
    {
        bgfx::reset(width, height, reset);
        // Enable debug text.
        bgfx::setDebug(debug);
        // Set view 0 clear state.
        bgfx::setViewClear(0
            , BGFX_CLEAR_COLOR|BGFX_CLEAR_DEPTH|BGFX_CLEAR_STENCIL
            , 0x203030ff
            , 1.0f
            , 0
            );
        }
        // Shutdown bgfx.
       bgfx::shutdown();
       return 0
}
```

#### 主循环

为了使程序在我们明确告诉他要关闭窗口之前一直保持运行状态而不是执行一次绘图之后就退出，我们需要给我们的应用程序添加一个循环。这个循环通常被称为*主循环*或*主消息循环*。每次循环都获取来自系统窗口的事件消息，检查到关闭窗口的消息时停止循环，在这个循环内我们处理其他的窗口消息并进行绘图操作。

```c++
while (!entry::processEvents(width, height, debug, reset) )
{            
    // Set view 0 default viewport.
    bgfx::setViewRect(0, 0, 0, width, height);

    // This dummy draw call is here to make sure that view 0 is cleared
    // if no other draw calls are submitted to view 0.
    bgfx::touch(0);

    // Use debug font to print information about this example.
    bgfx::dbgTextClear();
    bgfx::dbgTextPrintf(0, 0, 0x4f, "Entry:HelloWorld");
    // Advance to next frame. Rendering thread will be kicked to
    // process submitted rendering primitives.
    bgfx::frame();
}
```

### 使用`entry::AppI`接口

BGFX示例的entry定义了一个方便的应用程序管理借口`AppI`,这是一个纯虚类，其声明如下所示

```c++
struct BX_NO_VTABLE AppI
{
    virtual ~AppI() = 0;
    virtual void init(int _argc, char** _argv) = 0;
    virtual int  shutdown() = 0;
    virtual bool update() = 0;
};
```
代码是自注释型的，我就不用多说了，我们可以通过继承并重写其方法来更加方便的管理我们的BGFX窗口应用程序。

```c++
class App : public entry::AppI
{
public:
    App() = default;
    virtual ~App(){};        
    virtual void init(int _argc, char** _argv);
    virtual int  shutdown() override;
    virtual bool update() override;
protected:
    unsigned m_width  = 1280; // Window width
    unsigned m_height = 720;  // Window height
    unsigned m_debug  = BGFX_DEBUG_TEXT;
    unsigned m_reset   = BGFX_RESET_VSYNC;
};
```

## 使用其他方式

如果你不喜欢使用BGFX的entry来创建渲染窗口，也有其他的途径可以做到的。如果你不想自己写一套的话，你可以试试[GLFW](http://www.glfw.org/)来创建运行与Windows、Linux、Mac OSX上的OpenGL窗口管理库，也有另外两个个比较常用的[SDL](https://www.libsdl.org/)和[SFML](http://www.sfml-dev.org/) 。另外一个在Github的开源项目也可以用来在iOS、WebGL和Android上做同样的事情，有兴趣可以看看[glfm](https://github.com/brackeen/glfm)。
