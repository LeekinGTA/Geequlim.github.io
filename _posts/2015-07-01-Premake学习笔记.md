---
layout: post
title:  Premake学习笔记
category: 技术
tags: Essay
description: 
---

#Premake学习笔记

##使用方法

>最简单的使用方法如下所示

```bash
$ premake5 [action]
```

其中action表示要生成的项目类型名称

Action      | 描述
         ---|---
vs2015      | 生成 Visual Studio 2015 项目文件
vs2013      | 生成 Visual Studio 2013 项目文件
vs2012      | 生成 Visual Studio 2012 项目文件
vs2010      | 生成 Visual Studio 2010 项目文件
vs2008      | 生成 Visual Studio 2008 项目文件
vs2005      | 生成 Visual Studio 2005 项目文件
gmake	      | 生成 GNU Makefiles (包括 Cygwin 和 MinGW)
xcode	      | XCode projects (built-in extension)
monodevelop	| MonoDevelop/Xamarin projects (built-in extension)
codelite	  | CodeLite 项目 (built-in extension)

例如你可以这样生成一个Visual Studio 2013的项目文件
```bash
$ premake5 vs2013
```

有一些在Premake4中支持的项目现在不再支持了，可以查看 (Available Feature Matrix )[https://github.com/premake/premake-core/wiki/Feature-Matrix]
来了解详情。

通过 **__help** 指令来查看你安装的版本支持那些操作。

```bash
$ premake5 --help
```
###使用生成的项目

如果你生成的是 Visual Studio 或 Xcode 的项目文件你可以在你的集成开发环境（IDE）中手动选择配置。

如果你生成的是 Makefile 文件，那么你需要在使用 **make** 命令时选择一些配置参数。要查看所有的可选配置，键入以下命令：

```bash
$ make help
```

要构建不同的配置，需要添加配置参数：

```bash
$ make config=release
```

清理你的项目（删除所有生成的二进制文件和中间文件）：

{% highlight bash %}  
$ make clean                 # 清理默认配置
$ make config=release clean  # 清理不同的配置
{% endhighlight %}  

注意：Premake 生成的的 Makefile 文件目前不支持 **make install** 操作。然而我们建议用户手动编写安装脚本，这样做的好处是，能够让安装工作在任何平台上正常进行。


---

##第一个Premake5脚本

老规矩，写个 **HelloWorld.cpp** 吧

{% highlight c++ %}  
#include <iostream>
using namespace std;

int main(void)
{
    cout << "Hello World" << endl;
}
{% endhighlight %}

现在我们来书写第一个Premake5脚本

```lua
solution "HelloWorld"
   configurations { "Debug", "Release" }

project "HelloWorld"
   kind "ConsoleApp"
   language "C++"
   targetdir "bin/%{cfg.buildcfg}"

   files { "**.h", "**.cpp" }

   filter "configurations:Debug"
      defines { "DEBUG" }
      flags { "Symbols" }

   filter "configurations:Release"
      defines { "NDEBUG" }
      optimize "On"
```
If you save this script as a file named premake5.lua, and place it in the same directory as hello.c above, you can then generate project files by running a command like this one:

把这个脚本保存在 **HelloWorld.cpp** 所在的的目录并命名为 **premake5.lua**
然后执行

```bash
$ premake5 vs2013
```
此操作将会生成 HelloWorld.sln 和 HelloWorld.vcxproj 两个文件。如果你用Visual Studio2013构建这个项目将会bin/Debug 或 bin/Release目录下得到一个
名为HelloWorld.exe的可执行文件。

如果你使用Linux系统，你也需要执行下面的命令：

```bash
$ premake5 gmake
$ make                # 默认以Debug方式构建项目
$ make config=release # 以Release方式构建项目
$ make help           # 通过帮助查看可用的配置
```

若果你不想将脚本保存为 **premake5.lua** 你也可以保存为其他的文件名，不过在执行premake5命令时需要制定脚本文件：

```
$ premake5 --file=MyProjectScript.lua vs2013
```

####函数与参数说明

我们的第一个脚本中的每一行都是一个函数调用，由于Lua语言在函数参数只有一个**字符串 或 tabel** 参数时可以不写括号这一特性，我们可能误将这些函数调用操作理解为变量的定义。
因此这些代码也可以改写为下面的样子：

```lua
solution("HelloWorld")
configurations({ "Debug", "Release" })
```

如果你使用其他类型的参数的话，圆括号是必不可少的：

```lua
local lang = "C++"
language (lang)  -- 使用变量，圆括号必不可少

solution("HelloWorld" .. _ACTION) -- 使用字符串拼接，圆括号不能省略
```

####参数值和列表参数
Most of Premake's functions accept either a single string or a list of strings as arguments. Single string arguments are easy to use and understand.

许多Premake函数都接受一个字符串或一个字符串列表作为其参数。单个字符串作为参数的函数很容易理解。

```lua
language "C++"
```
如果对接受单个字符串作为参数的函数多次调用，其效果将于最后一次调用保持一致。

```lua
language "C++"   -- 值被设置为“C++”
language "C"     -- 再次调用，值被修改为了“C”
```

对于接受多个字符串（字符串列表）为参数的函数，你可以多次调用，并且你传入的参数都是有效的。

```lua
defines { "DEBUG", "TRACE" }  -- 现在的值为 { "DEBUG", "TRACE" }
defines { "WINDOWS" }         -- 现在的值为 { "DEBUG", "TRACE", "WINDOWS" }
```
如果你想移除某个值，所有的设置函数都有对应的remove函数，例如：

```lua
defines { "DEBUG", "TRACE" }  -- 现在的值为 { "DEBUG", "TRACE" }
removedefines { "TRACE" }     -- 现在的值为 { "DEBUG" }
```

###关于文件路径

你会在Premake中使用大量的文件路径，请记住以下两个原则：

* 使用脚本文件的所在目录的相对路径。
* 路径分隔符一律使用斜杠（“/”）。


---

##解决方案和项目（Solutions and Projects)

方便起见，Premake的许多概念都与Visual Studio相通，他们使用类似的结构和名称来管理构建项目。

###解决方案（Solutions）

解决方案作为整个构建项目的顶层，是一个能够包含许多项目的容器。在XCode中被称之为工作空间（Workspace）。

解决方案定义了一些被所包含的各个项目之间公用的配置（configurations、platforms）。你也可以为解决方案添加一些其他的配置（如宏定义、头文件路径等），这些配置
在此解决方案所包含的项目中都是有效的。

Premake中的解决方案都是使用 **solution** 函数来定义的。多数情况下我们只需要一个解决方案，当然，如果你有需要的话，也可以创建更多。解决方案的配置是使用
**configurations** 函数设置的，并且对解决方案进行一些配置是必要的（请参见Configurations与Platforms）。

```lua
solution "HelloWorld"
   configurations { "Debug", "Release" }
```

解决方案名通过solution函数名来给定，这个名称经被用于创建解决方案对应的文件，为了能够创建合法的文件名尽量不要使用特殊符号（空格是合法的）。如果你想用
不同的名称作为生成解决方案的文件名，可以通过 **filename** 函数来设置为你想要的文件名。

```lua
solution "Hello World"
   filename "Hello"
   configurations { "Debug", "Release" }
```

###项目（Projects）

解决方案的设计目的是用来包含项目的。**项目** 是用来组织一个构建活动所需的源代码文件和生成配置的一些配置列表。你可以把一个项目理解为是一个用来生成
某个特定的链接库或可执行文件的 **makefile**，而解决方案是一个用来构建各个项目的 **meta-makefile**。

Projects are defined using the project function. You must create the containing solution first.

项目通过 **project** 函数来创建，在创建项目前必须先创建解决方案。

```lua
solution "MySolution"
  configurations { "Debug", "Release" }

project "MyProject"
```

与解决方案名一样，项目名称也用于项目所创建的文件名称。同样，你可以通过 **filename** 函数来设置生成的项目文件的名称。

每一个项目必须设定一个类型（Kind）用来确定这个项目生成所的文件，例如控制台程序、窗口应用程序、静态链接库、动态链接库。
我们用 **kind** 函数来设置项目的类型。

同时每一个项目都需要指明它所使用的编程语言，例如C、C++、C#。我们用 **language** 函数来设置项目所使用的编程语言。

```lua
project "MyProject"
  kind "ConsoleApp"
  language "C++"
```

###项目路径（Locations）

在默认情况下，Premake会把生成的解决方案和项目文件都放在用来生成的Premake脚本所在的同一目录下。例如，如果你的Premake脚本文件位于
C:\Code\MyProject目录下，那么所生成的文件也会被放到C:\Code\MyProject目录里。你可以使用 **location** 函数来修改生成文件的目标目录。

```lua
solution "MySolution"
  configurations { "Debug", "Release" }
  location "build"

project "MyProject"
  location "build/MyProject"
```

与其他所有的路径相同，用来指定生成文件的目标目录也必须用脚本文件所在的目录的相对路径来表述。在此例中，生成的解决方案文件和项目文件将分别被放到
C:\Code\MyProject\build 和 C:\Code\MyProject\build\MyProject 目录下。

---

##作用范围与继承（Scopes and Inheritance）

在前面的例子中你也许已经注意到，Premake使用伪声明（pseudo-declarative）语法来指定项目信息。例如，创建一个解决方案时声明了一个作用域，当你再创建一个项目
的时候便又创建了另一个作用域。

变量的作用域具有继承性：解决方案被放在全局作用域内，并且包含着一些项目。在外部声明的变量会被内部的范围所继承，因此解决方案继承了全局作用域内的变量，项目作用域
继承了解决方案内的变量。

```lua
-- 全局作用域，所有的解决方案都可以检索到此作用域内的变量。
defines { "GLOBAL" }

solution "MySolution"
  -- 解决方案作用域，继承了全局作用域的内容
  -- 现在 defines 的列表值为 { "GLOBAL", "SOLUTION" }
  defines { "SOLUTION" }

project "MyProject"
  -- 项目作用域，继承了解决方案作用域
  -- 现在 defines 的列表值为 { "GLOBAL", "SOLUTION", "PROJECT" }
  defines { "PROJECT" }
```

Sometimes it can be helpful to go back and add values to a previously declared scope. You can do this the same way you declared it in the first place: by calling solution() or project(), using the same name.

有时回到上层作用域来改变之前的变量值视很有用的，你可以通过再次调用 **solution** 或 **project** 函数来实现：

```lua
-- 声明MySolution解决方案
solution "MySolution"
  defines { "SOLUTION1" }

-- 声明一两个项目
project "MyProject"
  defines { "PROJECT" }

-- 重新选择解决方案来添加更多配置，之前的配置并不会被抹去
-- 为解决方案MySolution内的所有项目配置
solution "MySolution"
  defines { "SOLUTION2" }  -- 值为 { "SOLUTION1", "SOLUTION2" }
```

你也可以通过 “*” 来返回到上一级作用域，这样不必写上一级作用域的具体名称

```lua
-- 声明解决方案
solution "MySolution"
  defines { "SOLUTION1" }

-- 声明一两个项目
project "MyProject"
  defines { "PROJECT" }

-- 重新选择解决方案来添加更多配置
project "*"
  defines { "SOLUTION2" }  -- value is now { "SOLUTION1", "SOLUTION2" }

-- 重新选择全局作用域
solution "*"
```

可以把 **\*** 理解为 **同一解决方案内的所有项目** 或者 **所有解决方案**

---
##添加、移除文件

###添加文件

使用 *files* 函数可以添加源代码、资源以及其他文件到你的项目中。

```lua
files {
   "hello.h",  -- 可以用确切的文件名
   "*.c",      -- 也可以用通配符查找文件名
   "**.cpp"    -- 甚至，在子目录中递归查找并添加文件
}
```

在其他目录下的文件需要使用关于当前Premake脚本文件的相对路径。例如，Premake脚本文件位于 myproject/build 目录下，
而源代码文件放在 myproject/src 目录下，这些源代码文件应该这样添加：

```lua
files { "../src/*.cpp" }
```

再次提醒，Premake所使用的都是相对于脚本文件的相对路径，并且路径分隔符必须使用" **/** "。Premake会在生成各个平台的项目时完成路径转换。

###排除文件

有时你可能想要某个目录下的大多数文件而不是全部。此时，使用 **removefiles** 函数来排除那些你不需要的文件。

```lua
files { "*.c" }
removefiles { "a_file.c", "another_file.c" }
```

一样可以使用通配符来指定要排除文件

```lua
files { "**.c" }
removefiles { "tests/*.c" }
```

有时，你可能想要排除某个文件夹下的所有文件，但你不记得这个文件夹的具体路径层次，你可以这样干：

```lua
files { "**.c" }
removefiles { "**/Win32Specific/**" }
```

---

##链接（Linking）

###添加链接库

添加外部链接库使用 **links** 函数。

```lua
links { "png", "zlib" }
```

在指定链接库时，链接库的文件名称中的系统特定的装饰,诸如前缀和后缀（例如Windows中静态链接库的后缀是".lib" 而 \*nix 系统的是".a"），都需要被忽略掉。
Premake会根据生成的平台自动推断出正确的文件名。但是也有一个例外，就是在使用Mac OS X的Apple所提供的那些Frameworks,此时文件后缀是必要的。

```lua
links { "Cocoa.framework" }
```

要把同胞项目（同一个解决方案下的其他项目）作为链接库，只需要传入项目名称即可。Premake会根据当前平台和配置推断出正确的库文件的路径。

```lua
solution "MySolution"

   project "MyLibraryProject"
      -- ...在此配置链接库项目...

   project "MyExecutableProject"
      -- ...在此设置可执行程序项目...
      links { "MyLibraryProject" } --将MyLibraryProject作为链接库
```

###查找链接库

你可以通过 **libdirs** 函数来告诉Premake到哪里去查找链接库。

```lua
libdirs { "libs", "../mylibs" }
```
如果你想用系统的库文件目录，可以使用 **os.findlib** 函数

```lua
libdirs { os.findlib("X11") }
```
